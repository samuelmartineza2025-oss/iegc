<!DOCTYPE html>
<html lang="es">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Juego de la Morcilla</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        /* Estilos personalizados para el juego */
        body {
            font-family: 'Inter', sans-serif;
            background-color: #1f2937; /* Gris oscuro */
        }
        #game-board {
            box-shadow: 0 4px 6px -1px rgba(0, 0, 0, 0.1), 0 2px 4px -2px rgba(0, 0, 0, 0.1);
        }
    </style>
</head>
<body class="flex items-center justify-center min-h-screen p-4">

    <div class="flex flex-col items-center bg-gray-800 p-6 rounded-xl shadow-2xl max-w-2xl w-full">
        <h1 class="text-3xl font-extrabold text-red-700 mb-4">‚ö´ La Gran Morcilla: La Carrera üçû</h1>
        
        <!-- Marcadores del juego -->
        <div class="flex justify-between w-full text-white mb-4 p-3 bg-gray-900 rounded-lg">
            <div class="text-lg font-semibold">Puntuaci√≥n: <span id="score">0</span></div>
            <div class="text-lg font-semibold">Velocidad: <span id="speed-indicator">Normal</span></div>
        </div>

        <!-- √Årea de juego: fondo negro. Aumentamos el tama√±o a 600x600. -->
        <canvas id="game-board" class="border-4 border-red-700 rounded-lg bg-black" width="600" height="600"></canvas>

        <!-- Controles/Instrucciones para m√≥vil -->
        <div id="controls-panel" class="mt-6 w-full flex flex-col items-center">
            <p class="text-gray-400 text-sm mb-3">Usa las **flechas del teclado** para mover.</p>
            <div class="grid grid-cols-3 gap-2 w-48">
                <button onclick="changeDirection('UP')" class="col-start-2 p-3 bg-red-600 hover:bg-red-700 text-white font-bold rounded-lg shadow-md transition duration-150">‚ñ≤</button>
                <button onclick="changeDirection('LEFT')" class="p-3 bg-red-600 hover:bg-red-700 text-white font-bold rounded-lg shadow-md transition duration-150">‚óÄ</button>
                <button onclick="changeDirection('DOWN')" class="p-3 bg-red-600 hover:bg-red-700 text-white font-bold rounded-lg shadow-md transition duration-150">‚ñº</button>
                <button onclick="changeDirection('RIGHT')" class="p-3 bg-red-600 hover:bg-red-700 text-white font-bold rounded-lg shadow-md transition duration-150">‚ñ∂</button>
            </div>

            <!-- Bot√≥n de Reinicio -->
            <button id="restart-button" onclick="startGame()" class="mt-4 p-3 w-48 bg-red-600 hover:bg-red-700 text-white font-bold rounded-lg shadow-lg transition duration-150 transform hover:scale-105" style="display: none;">
                Reiniciar Juego
            </button>
        </div>

        <!-- Mensaje de Fin de Juego -->
        <div id="message-box" class="fixed inset-0 bg-black bg-opacity-70 flex items-center justify-center hidden">
            <div class="bg-gray-700 p-8 rounded-xl shadow-2xl text-center border-4 border-red-500">
                <h2 id="message-text" class="text-4xl font-extrabold text-red-400 mb-4">¬°Juego Terminado!</h2>
                <p class="text-white text-xl mb-6">Tu puntuaci√≥n final es: <span id="final-score" class="font-bold text-yellow-300">0</span></p>
                <button onclick="startGame()" class="p-3 bg-red-600 hover:bg-red-700 text-white font-bold rounded-lg shadow-md transition duration-150">Jugar de Nuevo</button>
            </div>
        </div>

    </div>

    <script>
        // Configuraci√≥n del juego
        const canvas = document.getElementById('game-board');
        const ctx = canvas.getContext('2d');
        const scoreDisplay = document.getElementById('score');
        const speedIndicator = document.getElementById('speed-indicator');
        const messageBox = document.getElementById('message-box');
        const messageText = document.getElementById('message-text');
        const finalScoreDisplay = document.getElementById('final-score');
        const restartButton = document.getElementById('restart-button');
        
        // Tama√±os
        const GRID_SIZE = 20; // Tama√±o del bloque en p√≠xeles
        let TILE_COUNT = 30; // 600 / 20 = 30. Se recalcula en window.onload.
        
        // Propiedades del juego
        let snake = [];
        let dx = GRID_SIZE;
        let dy = 0;
        let bread = {};     // ¬°Ahora es pan!
        let enemies = [];   // Bolas enemigas
        const ENEMY_COUNT = 5; // Aumentado de 3 a 5
        const ENEMY_SPEED = GRID_SIZE / 4; // Aumentado para mayor dificultad (antes era / 8)
        
        let score = 0;
        let gameLoopInterval = null;
        let gameSpeed = 100; // Milisegundos por fotograma
        let isPaused = false;
        let lastDirection = 'RIGHT';


        // --- Funciones de Inicializaci√≥n ---

        /**
         * Inicializa la posici√≥n de las bolas enemigas.
         */
        function initializeEnemies() {
            enemies = [];
            for (let i = 0; i < ENEMY_COUNT; i++) {
                let newEnemy = generateSafePosition();
                // A√±adir propiedades de movimiento inicial aleatorio para el modo 'random walk'
                newEnemy.moveDirX = Math.floor(Math.random() * 3) - 1; // -1, 0, 1
                newEnemy.moveDirY = Math.floor(Math.random() * 3) - 1; // -1, 0, 1
                enemies.push(newEnemy);
            }
        }

        /**
         * Genera una posici√≥n de cuadr√≠cula aleatoria.
         */
        function getRandomTilePosition() {
            return Math.floor(Math.random() * TILE_COUNT) * GRID_SIZE;
        }

        /**
         * Genera una posici√≥n que no colisione con la serpiente, el pan o los enemigos existentes.
         * @returns {Object} - La posici√≥n segura {x, y}.
         */
        function generateSafePosition() {
            let pos = { x: getRandomTilePosition(), y: getRandomTilePosition() };

            const isOverlapping = (checkPos) => {
                // Revisar contra la serpiente
                const overlapsSnake = snake.some(segment => segment.x === checkPos.x && segment.y === checkPos.y);
                
                // Revisar contra el pan
                const overlapsBread = bread.x === checkPos.x && bread.y === checkPos.y;

                // Revisar contra otros enemigos (para que no aparezcan apilados)
                const overlapsEnemy = enemies.some(enemy => 
                    Math.abs(enemy.x - checkPos.x) < GRID_SIZE && Math.abs(enemy.y - checkPos.y) < GRID_SIZE
                );

                return overlapsSnake || overlapsBread || overlapsEnemy;
            };

            while (isOverlapping(pos)) {
                pos = { x: getRandomTilePosition(), y: getRandomTilePosition() };
            }
            return pos;
        }


        /**
         * Define y coloca los obst√°culos iniciales en el tablero. (Ahora vac√≠o)
         */
        function initializeObstacles() {
            // Eliminamos los obst√°culos fijos
            // La variable 'obstacles' ya no se usa, pero la funci√≥n se mantiene por claridad.
        }

        /**
         * Inicializa o reinicia el juego.
         */
        function startGame() {
            if (gameLoopInterval) {
                clearInterval(gameLoopInterval);
            }
            
            initializeObstacles(); // Vac√≠a los obst√°culos
            
            messageBox.classList.add('hidden');
            restartButton.style.display = 'none';

            // Estado inicial de la serpiente
            snake = [
                { x: 10 * GRID_SIZE, y: 10 * GRID_SIZE },
                { x: 9 * GRID_SIZE, y: 10 * GRID_SIZE },
                { x: 8 * GRID_SIZE, y: 10 * GRID_SIZE },
                { x: 7 * GRID_SIZE, y: 10 * GRID_SIZE }
            ];
            
            dx = GRID_SIZE;
            dy = 0;
            score = 0;
            gameSpeed = 100;
            lastDirection = 'RIGHT';
            isPaused = false;
            
            scoreDisplay.textContent = score;
            updateSpeedIndicator();
            
            placeBread(); // Colocamos el pan
            initializeEnemies(); // Colocamos los enemigos
            
            gameLoopInterval = setInterval(gameLoop, gameSpeed);
        }

        // --- Funciones de Juego ---

        /**
         * Genera una posici√≥n aleatoria para el pan.
         */
        function placeBread() {
            bread = generateSafePosition();
        }
        
        /**
         * Mueve las bolas enemigas. Tienen movimiento semi-aleatorio y persiguen a la serpiente si est√°n cerca.
         */
        function moveEnemies() {
            const head = snake[0];
            const CHASE_RANGE = 10 * GRID_SIZE; // Rango de 10 bloques para empezar a perseguir

            enemies.forEach(enemy => {
                let moveX = 0;
                let moveY = 0;

                // Distancia absoluta al enemigo
                const distanceX = Math.abs(head.x - enemy.x);
                const distanceY = Math.abs(head.y - enemy.y);
                
                // Si est√° dentro del rango, entra en modo persecuci√≥n (usa la velocidad m√°xima ENEMY_SPEED)
                if (distanceX < CHASE_RANGE && distanceY < CHASE_RANGE) {
                    if (head.x > enemy.x) moveX = ENEMY_SPEED;
                    else if (head.x < enemy.x) moveX = -ENEMY_SPEED;
                    if (head.y > enemy.y) moveY = ENEMY_SPEED;
                    else if (head.y < enemy.y) moveY = -ENEMY_SPEED;
                } else {
                    // Modo de paseo aleatorio (usa 1/3 de la velocidad m√°xima)
                    if (Math.random() < 0.02) { // 2% de probabilidad de cambiar de direcci√≥n
                        enemy.moveDirX = Math.floor(Math.random() * 3) - 1; // -1, 0, 1
                        enemy.moveDirY = Math.floor(Math.random() * 3) - 1; // -1, 0, 1
                    }
                    moveX = enemy.moveDirX * ENEMY_SPEED / 3;
                    moveY = enemy.moveDirY * ENEMY_SPEED / 3;
                }
                
                // Aplicar movimiento y limitar a los bordes del mapa (para que no salgan)
                enemy.x += moveX;
                enemy.y += moveY;
                
                enemy.x = Math.max(0, Math.min(canvas.width - GRID_SIZE, enemy.x));
                enemy.y = Math.max(0, Math.min(canvas.height - GRID_SIZE, enemy.y));
            });
        }

        /**
         * Bucle principal del juego.
         */
        function gameLoop() {
            if (isPaused) return;
            
            // 0. Mover enemigos antes de mover la serpiente
            moveEnemies();

            // 1. Mover la cabeza de la serpiente
            let head = { x: snake[0].x + dx, y: snake[0].y + dy };
            
            // --- Implementar el 'Wrap-Around' (No morir al chocar con paredes) ---
            if (head.x < 0) head.x = canvas.width - GRID_SIZE;
            else if (head.x >= canvas.width) head.x = 0;
            if (head.y < 0) head.y = canvas.height - GRID_SIZE;
            else if (head.y >= canvas.height) head.y = 0;
            // -------------------------------------------------------------------------
            
            // 2. Comprobar colisiones (cuerpo, enemigos)
            if (checkCollision(head)) {
                gameOver();
                return;
            }

            // 3. A√±adir la nueva cabeza al frente
            snake.unshift(head);
            
            // 4. Comprobar si come el pan
            if (head.x === bread.x && head.y === bread.y) {
                score++;
                scoreDisplay.textContent = score;
                placeBread();
                increaseSpeed();
            } else {
                // 5. Si no come, quitar la cola (movimiento normal)
                snake.pop();
            }

            // 6. Dibujar todo
            drawGame();
        }

        /**
         * Aumenta la velocidad del juego cada 5 puntos.
         */
        function increaseSpeed() {
             if (score > 0 && score % 5 === 0) {
                gameSpeed = Math.max(50, gameSpeed - 5);

                clearInterval(gameLoopInterval);
                gameLoopInterval = setInterval(gameLoop, gameSpeed);
                updateSpeedIndicator();
            }
        }

        /**
         * Actualiza el indicador de velocidad.
         */
        function updateSpeedIndicator() {
            let speedText;
            if (gameSpeed > 80) speedText = 'Normal';
            else if (gameSpeed > 60) speedText = 'R√°pida';
            else speedText = '¬°Muy R√°pida!';
            speedIndicator.textContent = speedText;
        }

        /**
         * Dibuja el tablero, el pan, los enemigos y la serpiente.
         */
        function drawGame() {
            // Limpiar el tablero (fondo negro)
            ctx.fillStyle = 'black';
            ctx.fillRect(0, 0, canvas.width, canvas.height);
            
            // Dibujar el pan (color crema/tan)
            ctx.fillStyle = '#D2B48C'; // Tan (Pan)
            ctx.shadowColor = '#D2B48C';
            ctx.shadowBlur = 10;
            ctx.fillRect(bread.x, bread.y, GRID_SIZE, GRID_SIZE); 
            ctx.shadowBlur = 0; 

            // Dibujar las bolas enemigas (rojas)
            ctx.fillStyle = '#EF4444'; // Rojo vibrante
            ctx.shadowColor = '#EF4444';
            ctx.shadowBlur = 15;
            enemies.forEach(enemy => {
                // Dibujar como un c√≠rculo (bola) centrado en el tile
                ctx.beginPath();
                ctx.arc(enemy.x + GRID_SIZE / 2, enemy.y + GRID_SIZE / 2, GRID_SIZE / 2 * 0.9, 0, 2 * Math.PI);
                ctx.fill();
            });
            ctx.shadowBlur = 0;

            // Dibujar la serpiente
            snake.forEach(drawSnakeSegment);
        }

        /**
         * Dibuja un segmento de la serpiente, con la cola m√°s ancha (La Morcilla).
         */
        function drawSnakeSegment(segment, index) {
            
            // Color base: caf√© oscuro (cuerpo) y caf√© claro (cabeza)
            ctx.fillStyle = index === 0 ? '#6F4F28' : '#8B4513';
            
            let size = GRID_SIZE;
            let offset = 0;

            if (index === 0) {
                // Cabeza
                size = GRID_SIZE * 0.9; 
                offset = (GRID_SIZE - size) / 2;
                ctx.fillStyle = '#6F4F28';
                ctx.strokeStyle = '#333';

            } else if (index === snake.length - 1) {
                // Cola m√°s ancha
                const tailSizeFactor = 1.3; 
                size = GRID_SIZE * tailSizeFactor;
                offset = (GRID_SIZE - size) / 2;
                ctx.fillStyle = '#5C3317';
            }
            
            // Dibujar el cuadrado
            ctx.fillRect(segment.x + offset, segment.y + offset, size, size);
            
            // A√±adir un borde sutil
            ctx.strokeStyle = '#3D2210';
            ctx.strokeRect(segment.x + offset, segment.y + offset, size, size);
        }

        /**
         * Comprueba colisiones con cuerpo propio y enemigos. (Las paredes ya no causan muerte)
         * @param {Object} head - La posici√≥n de la nueva cabeza.
         * @returns {boolean} - Verdadero si hay colisi√≥n.
         */
        function checkCollision(head) {
            // Colisi√≥n con el propio cuerpo
            const selfCollision = snake.slice(4).some(segment => segment.x === head.x && segment.y === head.y);

            // Colisi√≥n con los enemigos (check si la cabeza de la serpiente y el enemigo ocupan el mismo tile de cuadr√≠cula)
            const enemyCollision = enemies.some(enemy => 
                // Convertir la posici√≥n flotante del enemigo a la posici√≥n de la cuadr√≠cula m√°s cercana
                Math.floor(enemy.x / GRID_SIZE) * GRID_SIZE === head.x && 
                Math.floor(enemy.y / GRID_SIZE) * GRID_SIZE === head.y
            );

            // Solo se muere por golpearse a s√≠ mismo o golpear/ser golpeado por un enemigo
            return selfCollision || enemyCollision;
        }

        /**
         * Maneja el evento de fin de juego.
         */
        function gameOver() {
            clearInterval(gameLoopInterval);
            finalScoreDisplay.textContent = score;
            messageBox.classList.remove('hidden');
            restartButton.style.display = 'block';
        }

        // --- Manejo de Controles ---

        document.addEventListener('keydown', e => {
            const key = e.key;
            if (key === 'ArrowUp' || key === 'ArrowDown' || key === 'ArrowLeft' || key === 'ArrowRight') {
                e.preventDefault();
                handleKeyInput(key.replace('Arrow', '').toUpperCase());
            }
            if (key === ' ' || key === 'Spacebar') {
                e.preventDefault();
                togglePause();
            }
        });

        function changeDirection(direction) {
            handleKeyInput(direction);
        }

        function handleKeyInput(newDirection) {
            if (isPaused) return;

            const goingUp = dy === -GRID_SIZE;
            const goingDown = dy === GRID_SIZE;
            const goingLeft = dx === -GRID_SIZE;
            const goingRight = dx === GRID_SIZE;

            if (newDirection === 'UP' && !goingDown) { dx = 0; dy = -GRID_SIZE; lastDirection = 'UP'; }
            else if (newDirection === 'DOWN' && !goingUp) { dx = 0; dy = GRID_SIZE; lastDirection = 'DOWN'; }
            else if (newDirection === 'LEFT' && !goingRight) { dx = -GRID_SIZE; dy = 0; lastDirection = 'LEFT'; }
            else if (newDirection === 'RIGHT' && !goingLeft) { dx = GRID_SIZE; dy = 0; lastDirection = 'RIGHT'; }
        }

        function togglePause() {
            isPaused = !isPaused;
            if (isPaused) {
                messageText.textContent = 'Juego en Pausa';
                finalScoreDisplay.textContent = score;
                messageBox.classList.remove('hidden');
            } else {
                messageBox.classList.add('hidden');
            }
        }
        
        // Iniciar el juego autom√°ticamente al cargar la ventana
        window.onload = function() {
            // Ajustar el tama√±o del canvas al m√°ximo de 600x600 o al ancho disponible
            const parentWidth = canvas.parentElement.clientWidth;
            const preferredSize = 600; 
            const size = Math.min(preferredSize, parentWidth - 32); 
            
            // Asegurar que el tama√±o sea un m√∫ltiplo de GRID_SIZE (20)
            canvas.width = size - (size % GRID_SIZE);
            canvas.height = canvas.width;
            
            // Actualizar TILE_COUNT globalmente basado en el tama√±o final del canvas
            TILE_COUNT = canvas.width / GRID_SIZE; 

            startGame();
            drawGame();
        };

    </script>
</body>
</html>
